"use strict";

require("core-js/modules/es6.array.find");

require("core-js/modules/es6.regexp.split");

require("core-js/modules/es6.regexp.replace");

require("core-js/modules/es6.regexp.match");

require("core-js/modules/es6.regexp.constructor");

require("core-js/modules/web.dom.iterable");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var defaultOptions = require('./statics/DefaultOptions.js');

var getValueFromObject = require('./lib/getValueFromObject.js');

var defaultModifiers = require('./modifiers');

var Interpolator =
/*#__PURE__*/
function () {
  function Interpolator() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultOptions;

    _classCallCheck(this, Interpolator);

    this.options = options;
    this.modifiers = [];
    this.aliases = [];
    this.registerBuiltInModifiers();
  }

  _createClass(Interpolator, [{
    key: "registerBuiltInModifiers",
    value: function registerBuiltInModifiers() {
      var _this = this;

      defaultModifiers.forEach(function (modifier) {
        return _this.registerModifier(modifier.key, modifier.transform);
      });
      return this;
    }
  }, {
    key: "delimiterStart",
    value: function delimiterStart() {
      return this.options.delimiter[0];
    }
  }, {
    key: "delimiterEnd",
    value: function delimiterEnd() {
      return this.options.delimiter[1];
    }
  }, {
    key: "registerModifier",
    value: function registerModifier(key, transform) {
      if (!key) {
        return new Error('Modifiers must have a key');
      }

      if (typeof transform !== 'function') {
        return new Error('Modifiers must have a transformer. Transformers must be a function that returns a value.');
      }

      this.modifiers.push({
        key: key.toLowerCase(),
        transform: transform
      });
      return this;
    }
  }, {
    key: "parseRules",
    value: function parseRules(str) {
      var regex = "".concat(this.delimiterStart(), "([^}]+)").concat(this.delimiterEnd());
      var execRegex = new RegExp(regex, 'gi');
      var matches = str.match(execRegex); // const parsableMatches = matches.map((match) => ({ key: removeDelimiter(match), replaceWith: match }));

      return matches ? this.extractRules(matches) : [];
    }
  }, {
    key: "extractRules",
    value: function extractRules(matches) {
      var _this2 = this;

      return matches.map(function (match) {
        var alternativeText = _this2.getAlternativeText(match);

        var modifiers = _this2.getModifiers(match);

        return {
          key: _this2.getKeyFromMatch(match),
          replace: match,
          modifiers: modifiers,
          alternativeText: alternativeText
        };
      });
    }
  }, {
    key: "getKeyFromMatch",
    value: function getKeyFromMatch(match) {
      var _this3 = this;

      var removeReservedSymbols = [':', '|'];
      return this.removeDelimiter(removeReservedSymbols.reduce(function (val, sym) {
        return val.indexOf(sym) > 0 ? _this3.removeAfter(val, sym) : val;
      }, match));
    }
  }, {
    key: "removeDelimiter",
    value: function removeDelimiter(val) {
      return val.replace(new RegExp(this.delimiterStart(), 'g'), '').replace(new RegExp(this.delimiterEnd(), 'g'), '');
    }
  }, {
    key: "removeAfter",
    value: function removeAfter(str, val) {
      return str.substring(0, str.indexOf(val));
    }
  }, {
    key: "extractAfter",
    value: function extractAfter(str, val) {
      return str.substring(str.indexOf(val) + 1);
    }
  }, {
    key: "getAlternativeText",
    value: function getAlternativeText(str) {
      if (str.indexOf(':') > 0) {
        var altText = this.removeDelimiter(this.extractAfter(str, ':'));

        if (altText.indexOf('|') > 0) {
          return this.removeAfter(altText, '|');
        }

        return altText;
      }

      return '';
    }
  }, {
    key: "getModifiers",
    value: function getModifiers(str) {
      var _this4 = this;

      if (str.indexOf('|') > 0) {
        var strModifiers = this.removeDelimiter(this.extractAfter(str, '|')).split(',');
        return strModifiers.map(function (modifier) {
          return _this4.getModifier(modifier.toLowerCase());
        });
      }

      return [];
    }
  }, {
    key: "parse",
    value: function parse() {
      var str = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var rules = this.parseRules(str);

      if (rules && rules.length > 0) {
        return this.parseFromRules(str, data, rules);
      }

      return str;
    }
  }, {
    key: "parseFromRules",
    value: function parseFromRules(str, data, rules) {
      var _this5 = this;

      return rules.reduce(function (reducedStr, rule) {
        return _this5.applyRule(reducedStr, rule, data);
      }, str);
    }
  }, {
    key: "applyRule",
    value: function applyRule(str, rule) {
      var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var dataToReplace = this.applyData(rule.key, data);

      if (dataToReplace) {
        return str.replace(rule.replace, this.applyModifiers(rule.modifiers, dataToReplace, data));
      } else if (rule.alternativeText) {
        return str.replace(rule.replace, this.applyModifiers(rule.modifiers, rule.alternativeText, data));
      }

      var defaultModifier = this.applyModifiers(rule.modifiers, rule.key, data);

      if (defaultModifier === rule.key) {
        return str.replace(rule.replace, '');
      }

      return str.replace(rule.replace, defaultModifier);
    }
  }, {
    key: "getFromAlias",
    value: function getFromAlias(key) {
      return this.aliases.find(function (alias) {
        return alias.key.toLowerCase() === key.toLowerCase();
      });
    }
  }, {
    key: "applyData",
    value: function applyData(key, data) {
      var alias = this.getFromAlias(key);

      if (alias) {
        var value = getValueFromObject(alias.ref, data);

        if (value) {
          return value;
        }
      }

      return key.indexOf('.') > 0 || key.indexOf('[') > 0 ? getValueFromObject(key, data) : data[key];
    }
  }, {
    key: "getModifier",
    value: function getModifier(key) {
      return this.modifiers.find(function (modifier) {
        return modifier.key === key;
      });
    }
  }, {
    key: "applyModifiers",
    value: function applyModifiers(modifiers, str, rawData) {
      try {
        var transformers = modifiers.map(function (modifier) {
          return modifier && modifier.transform;
        });
        return transformers.reduce(function (str, transform) {
          return transform ? transform(str, rawData) : str;
        }, str);
      } catch (e) {
        return str;
      }
    }
  }, {
    key: "addAlias",
    value: function addAlias(key, ref) {
      if (typeof ref === 'function') {
        this.aliases.push({
          key: key,
          ref: ref()
        });
      } else {
        this.aliases.push({
          key: key,
          ref: ref
        });
      }

      return this;
    }
  }, {
    key: "removeAlias",
    value: function removeAlias(key) {
      this.aliases = this.aliases.filter(function (alias) {
        return alias.key !== key;
      });
      return this;
    }
  }, {
    key: "delimiter",
    get: function get() {
      return this.options.delimiter;
    }
  }]);

  return Interpolator;
}();

module.exports = Interpolator;